// Шифр Цезаря

// На стандартном потоке ввода задается целое неотрицательное число N 
// и последовательность допустимых символов в кодировке ASCII, оканчивающаяся 
// точкой. Допустимые символы - латинские буквы 'a' ... 'z', 'A' ... 'Z' и пробел. 
// Требуется закодировать латинские буквы ('a' ... 'z', 'A' ... 'Z') шифром Цезаря, 
// пробелы вывести без изменения. Число N задает сдвиг в шифре. Шифр Цезаря 
// заключается в следующем преобразовании. Пусть буквы алфавита пронумерованы 
// от 0 до K - 1, где K - число символов в алфавите. Тогда символ с номером n 
// кодируется символом с номером p = (n + N) mod K (mod - операция взятия остатка). 
// На стандартном потоке вывода напечатать зашифрованное сообщение, оканчивающееся 
// точкой. Преобразование требуется выполнять независимо для заглавных и строчных 
// латинских букв. Указание: использовать массивы запрещается.

#include <stdio.h>

int main(int argc, char **argv)
{
    char c ='0';
    int number;

    if (scanf("%d", &number) != 1)
    {
        printf("Input error.");
        return 0;
    }

    while (1)
    {
        scanf("%c", &c);
        if( c == '.')
        {
            break;
        }

        char new_c;
        if(c >= 'a' && c <= 'z')
        {
            int shift = number%('z' - 'a' + 1);
            new_c = 'a' + (c - 'a' + shift)%('z' - 'a' +1);
            printf("%c", new_c);
        }else if(c >= 'A' && c <= 'Z')
        {
            int shift = number%('Z' - 'A' + 1);
            new_c = 'A' + (c - 'A' + shift)%('Z' - 'A' +1);
            printf("%c", new_c);
        }else if(c == ' ')
        {
            printf("%c", ' ');

        }
    }
    printf(".\n");
    return 0;
}