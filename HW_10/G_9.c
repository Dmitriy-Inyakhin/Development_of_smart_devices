// G_9.c
// Удалить повторяющиеся символы
// В файле input.txt строка из меленьких и больших английских букв,
// знаков препинания и пробелов. Требуется удалить из нее повторяющиеся
// символы и все пробелы. Результат записать в файл output.txt.

// Input format
//     Строка из меленьких и больших английских букв, знаков препинания
//     и пробелов. Размер строки не более 1000 сивмолов.
// Output format
//     Строка из меленьких и больших английских букв.
// Examples
// Input in input.txt
//     abc cde def
// Output in output.txt
//     abcdef

// Алгоритм:
//   1. Читаем строку из input.txt.
//   2. Используем булевский массив `seen[128]` для отслеживания уже встреченных
//      символов. Выбираем размер 128, потому что:
//        - вход состоит из ASCII-символов (буквы латинские, пробелы, пунктуация);
//        - стандартный ASCII — 0..127, этого достаточно;
//        - это эффективно по памяти и времени: O(1) на проверку символа.
//   3. Проходим по строке посимвольно:
//        - если символ — пробел (' '), пропускаем его (не добавляем вообще);
//        - если символ ещё не встречался (seen[c] == 0), помечаем его как
//          "встреченный" и добавляем в результирующую строку;
//        - если уже встречался — игнорируем.
//   4. Сохраняем результат в output.txt.
//
// Важные детали:
//   • Используем `unsigned char c = s[i]` при индексации в `seen`, потому что:
//       - тип `char` может быть знаковым (например, на x86);
//       - символы с кодами 128–255 (хотя по условию их не будет) или даже
//         отрицательные значения при приведении к `int` дали бы отрицательный
//         индекс → выход за границы массива.
//       - `unsigned char` гарантирует индекс 0..255, но так как мы используем
//         только ASCII (0–127), то 128 элементов достаточно и безопасно.
//   • Пробелы удаляются полностью — даже если он встречается впервые.
//   • Регистр сохраняется: 'A' и 'a' — разные символы (см. пример в условии —
//     там нет смешанного регистра, но задача допускает и то, и другое).
//   • Порядок — по первому появлению (не лексикографический!).
//   • Размер буфера `result` — 1001, как и `s`: худший случай — строка без пробелов
//     и без повторов (макс. 1000 символов + '\0').

#include <stdio.h>
#include <string.h>

int main()
{
    // Открываем входной файл
    FILE *in = fopen("input.txt", "r");
    if (!in)
        return 1; // если не удалось открыть — ошибка

    // Читаем строку (макс. 1000 символов + '\0')
    char strsimb[1001];
    if (!fgets(strsimb, sizeof(strsimb), in))
    {
        fclose(in);
        return 1;
    }
    fclose(in);

    // Массив меток: seen[c] == 1, если символ с кодом c уже был добавлен
    // Используем 128 элементов — достаточно для стандартного ASCII
    int seen[128] = {0}; // инициализация нулями

    // Результирующая строка и её текущая длина
    char result[1001];
    int len = 0;

    // Обрабатываем каждый символ входной строки
    for (int i = 0; strsimb[i] != '\0'; ++i)
    {
        // Преобразуем в unsigned char для безопасного индекса
        unsigned char c = (unsigned char)strsimb[i];

        // Пропускаем пробелы — по условию: "удалить все пробелы"
        if (c == ' ')
        {
            continue;
        }

        // Проверяем, не выходит ли c за пределы 0..127 (на случай не-ASCII)
        // По условию — только английские буквы, знаки, пробелы → ASCII, но для надёжности:
        if (c >= 128)
        {
            // Формально не должно быть, но если вдруг — пропустим
            continue;
        }

        // Если символ ещё не встречался — добавляем его в результат
        if (!seen[c])
        {
            seen[c] = 1;                // помечаем как встреченный
            result[len++] = strsimb[i]; // сохраняем исходный символ (сохраняем регистр)
        }
    }

    // Завершаем строку нулём
    result[len] = '\0';

    // Записываем результат в output.txt
    FILE *out = fopen("output.txt", "w");
    if (!out)
        return 1;
    fputs(result, out);
    fclose(out);

    return 0;
}