//  G_10.c
//  Самое длинное слово
//  В файле input.txt дана строка слов, разделенных пробелами. 
//  Найти самое длинное слово и вывести его в файл output.txt. 
//  Случай, когда самых длинных слов может быть несколько, не 
//  обрабатывать.

//  Input format
//      Строка из английских букв и пробелов. Не более 1000 символов.
//  Output format
//      Одно слово из английских букв.
//  Examples
//  Input in input.txt
//      Hello beautiful world
//  Output in output.txt
//      beautiful

//  Алгоритм:
//   1. Читаем строку из input.txt.
//   2. Проходим по строке, отслеживая начало и длину текущего слова.
//   3. При встрече пробела (или конца строки):
//        - если текущее слово длиннее сохранённого максимума — обновляем:
//          * начало самого длинного слова (указатель или индекс),
//          * его длину.
//   4. Копируем найденное слово в буфер и записываем в output.txt.
//
// Особенности:
//   • Игнорируем ведущие/концевые/повторные пробелы — strtok не используется,
//     чтобы избежать модификации строки и упростить логику.
//   • Работает даже при пустом входе (вывод — пустой файл).
//   • Не использует динамическую память — всё в стеке.

#include <stdio.h>
#include <string.h>

int main() {
    FILE *in = fopen("input.txt", "r");
    if (!in) return 1;

    char s[1001];
    if (!fgets(s, sizeof(s), in)) {
        fclose(in);
        return 1;
    }
    fclose(in);

    int max_len = 0;          // длина самого длинного слова
    int max_start = 0;        // индекс начала самого длинного слова
    int i = 0;
    int n = (int)strlen(s);

    while (i < n) {
        // Пропускаем пробелы
        while (i < n && s[i] == ' ') {
            i++;
        }

        if (i >= n) break;

        // Нашли начало слова
        int start = i;
        // Идём до следующего пробела или конца
        while (i < n && s[i] != ' ') {
            i++;
        }
        int len = i - start;

        // Если текущее слово длиннее предыдущего максимума — обновляем
        if (len > max_len) {
            max_len = len;
            max_start = start;
        }
        // Если len == max_len — оставляем первое (не обновляем)
    }

    // Записываем результат
    FILE *out = fopen("output.txt", "w");
    if (!out) return 1;

    // Выводим найденное слово (если есть)
    for (int j = 0; j < max_len; j++) {
        fputc(s[max_start + j], out);
    }
    // Если max_len == 0 (нет слов) — файл останется пустым, что корректно.

    fclose(out);
    return 0;
}